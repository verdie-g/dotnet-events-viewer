using System.Diagnostics;
using System.Text;

namespace NetTrace;

/// <summary>
/// .NET symbols are super verbose and hard to read. This class is responsible to make them look like as close
/// as possible as their original source code.
/// </summary>
/// <remarks>
/// This code is extremely complex because the symbols generated by the JIT are extremely inconsistent. Fortunately,
/// it is relatively well tested so it's easy to spot regressions.
/// </remarks>
internal static class SymbolCleaner
{
    public static string Clean(string ns, string name, string signature)
    {
        StringBuilder sb = new(capacity: ns.Length + name.Length + signature.Length);
        AppendCleanedType(sb, ns);

        if (name == ".ctor")
        {
            sb.Insert(0, "new ");
        }
        else if (name != "MoveNext")
        {
            sb.Append('.');
            sb.Append(name);
        }

        AppendCleanedArguments(sb, signature);
        return sb.ToString();
    }

    private static int AppendCleanedType(StringBuilder sb, ReadOnlySpan<char> str)
    {
        int typeNameStartIndex = -1;
        bool subType = false;
        int i;
        for (i = 0; i < str.Length; i += 1)
        {
            if (str[i] is ',' or ')' or '>' or ']')
            {
                break;
            }

            // Handle '[' and ']' together so they don't get interpreted as special characters.
            if (str[i] == '[' && str[i + 1] is ']' or ',')
            {
                while (str[i + 1] == ',')
                {
                    i += 1;
                }
                while (str[i + 1] == ']')
                {
                    i += 1;
                }
                continue;
            }

            if (str[i] is '`' or '[' or '<')
            {
                if (typeNameStartIndex != -1)
                {
                    AppendPrettifiedType(sb, str[typeNameStartIndex..i]);
                    typeNameStartIndex = -1;
                }

                // Some subclass names can contain '<', in that case it's not the start of type arguments.
                if (str[i] == '<' && subType)
                {
                    i += AppendCleanedGeneratedType(sb, str[i..]);
                }
                else
                {
                    i += AppendTypeArguments(sb, str[i..], hasTildeHeader: str[i] == '`');
                }

                i -= 1;
                continue;
            }

            if (str[i] == '+')
            {
                if (typeNameStartIndex != -1)
                {
                    AppendPrettifiedType(sb, str[typeNameStartIndex..i]);
                    typeNameStartIndex = -1;
                }

                sb.Append('+');
                subType = true;
                continue;
            }

            if (typeNameStartIndex == -1)
            {
                typeNameStartIndex = i;
            }
        }

        if (typeNameStartIndex != -1)
        {
            AppendPrettifiedType(sb, str[typeNameStartIndex..i]);
        }

        return i;
    }

    private static int AppendTypeArguments(StringBuilder sb, ReadOnlySpan<char> str, bool hasTildeHeader)
    {
        Debug.Assert(!hasTildeHeader || str[0] == '`');

        int i = 0;

        sb.Append('<');
        if (!hasTildeHeader
            || (str.Length > 2 && str[2] is '[' or '<')) // The type arguments are present.
        {
            i = hasTildeHeader ? 3 : 1;
            for (; i < str.Length && str[i] is not ']' and not '>';)
            {
                i += AppendCleanedType(sb, str[i..]);
                sb.Append(", ");
                if (str[i] == ',')
                {
                    i += 1;
                }
            }

            i += 1;
        }
        else
        {
            int typeArgumentsCount = CharToInt(str[1]);
            for (int j = 0; j < typeArgumentsCount; j += 1)
            {
                sb.Append("T, ");
            }

            i += 2;
        }

        sb.Length -= ", ".Length;
        sb.Append('>');

        return i;
    }

    private static void AppendCleanedArguments(StringBuilder sb, ReadOnlySpan<char> signature)
    {
        int openingParenthesisIndex = signature.IndexOf('(');
        if (openingParenthesisIndex == -1)
        {
            return;
        }

        sb.Append('(');

        if (signature[openingParenthesisIndex + 1] != ')')
        {
            for (int i = openingParenthesisIndex + 1; i < signature.Length; i += 1)
            {
                i += AppendCleanedType(sb, signature[i..]);
                sb.Append(", ");
            }

            sb.Length -= ", ".Length;
        }

        sb.Append(')');
    }

    /// <summary>
    /// Cleans generated types such as state machines.
    /// </summary>
    private static int AppendCleanedGeneratedType(StringBuilder sb, ReadOnlySpan<char> str)
    {
        // State machines (async/enumerable) look like <XXXXX>d__3 and can be nested like this <<XXXXX>g__YYYYY|3_1>d.
        // I couldn't find a symbol with more nesting than that so it's assume than 2 levels of nesting is the max here.

        if (sb.Length > 0 && sb[^1] == '+')
        {
            sb[^1] = '.';
        }

        int i = 0;
        for (; i < str.Length;)
        {
            if (str[i] is '[')
            {
                break;
            }

            if (str[i] == '+')
            {
                i += 1;
                continue;
            }

            if (str[i] == '<')
            {
                i += 1;
                continue;
            }

            if (str[i] == '>')
            {
                if (str[i + 1] is 'd' or 'b')
                {
                    i += 4; // Skips >d__
                    i += SkipDigits(str[i..]);
                    return i;
                }

                if (str[i + 1] == 'g')
                {
                    i += 4; // Skips >g__
                    sb.Append('.');
                    continue;
                }

                if (str[i + 1] == 'c')
                {
                    sb.Append("()=>{}");
                    if (i + 2 == str.Length || str[i + 2] != '_')
                    {
                        i += 2; // Skips >c
                        continue;
                    }

                    sb.Append('.');
                    i += 16; // Skips >c__DisplayClass
                    i += SkipDigits(str[i..]);
                    i += 1; // Skips _
                    i += SkipDigits(str[i..]);
                    continue;
                }

                // Error
                return str.Length;
            }

            if (str[i] == '|')
            {
                i += 1; // Skips |
                i += SkipDigits(str[i..]);
                if (str[i] == '_')
                {
                    i += 1; // Skips _
                    i += SkipDigits(str[i..]);
                }

                i += 2; // Skips >d
                return i;
            }

            sb.Append(str[i]);
            i += 1;
        }

        return i;

        static int SkipDigits(ReadOnlySpan<char> s)
        {
            int i = 0;
            while (i < s.Length && char.IsDigit(s[i]))
            {
                i += 1;
            }

            return i;
        }
    }

    private static void AppendPrettifiedType(StringBuilder sb, ReadOnlySpan<char> str)
    {
        if (str.Length == 0)
        {
            return;
        }

        str = TrimWordStart(str, "required_modifier ");
        str = TrimWordStart(str, "System.Runtime.InteropServices.InAttribute ");
        str = TrimWordStart(str, "value ");
        str = TrimWordStart(str, "class ");

        string suffix = "";
        if (str[^1] == '&')
        {
            suffix = "&";
            str = str[..^1];
        }
        else if (str[^1] == '*')
        {
            suffix = "*";
            str = str[..^1];
        }

        if (str.Equals("System.__Canon", StringComparison.Ordinal)
            || (str.Length >= 2 && str[0] == '!'))
        {
            sb.Append('T');
            sb.Append(suffix);
            return;
        }

        str = str switch
        {
            "int16" => "short",
            "int32" => "int",
            "unsigned int32" => "uint",
            "float32" => "float",
            "float64" => "double",
            "System.Int32" => "int",
            "System.Object" => "object",
            "System.String" => "string",
            _ => str,
        };

        sb.Append(str);
        sb.Append(suffix);
    }

    private static ReadOnlySpan<char> TrimWordStart(ReadOnlySpan<char> span, ReadOnlySpan<char> word)
    {
        return span.StartsWith(word) ? span[word.Length..] : span;
    }

    private static int CharToInt(char c)
    {
        return c - '0';
    }
}